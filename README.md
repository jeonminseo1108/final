
# SNU CS M1522.00800 : System Programming - Sample Final Exam Questions

We have prepared some practice problems.

These problems have been selected from those generated by **AI tools (Cramify and ChatGPT)**,  
based on your textbook content and previous exam questions.

There is no need to submit anything after reviewing this material,  
but we hope it will help you prepare for the Final exam.  

Good luck, and we hope this resource proves valuable in your studies!

## Question 1.
Give all possible output sequences of the code below.

```c
#include <stdio.h>
#include <unistd.h>

int main()
{
    int y = 5;

    if (fork() == 0)
    {
        y = y + 2;
        printf("y=%d\n", y);
    }
    else
    {
        y = y - 1;
        printf("y=%d\n", y);
    }
    if (fork() != 0)
        printf("y=%d\n", ++y);

    return 0;
}
```

## Question 2.
Give all possible output sequences of the code below.

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdlib.h>

int main()
{
    printf("a");
    if (fork() == 0)
    {
        printf("b");
        fflush(stdout);
    }
    else
    {
        printf("c");
        fflush(stdout);
        waitpid(-1, NULL, 0);
    }
    printf("d");
    fflush(stdout);
    exit(0);
}
```

## Question 3.
In general, thread-based parallel programming is often prioritized over process-based parallel programming due to the overhead of IPC.  
Then, is process-based parallel programming a method that has no applicable use cases?  
If it is applicable, in what scenarios can it be applied?  

## Question 4.
This is the simple client code that sends a message to the client.  
Assume that all the necessary header files are included.  
This client program will compile and run without error.  
However, this code may not work as you intended. Explain why.

```c
#define SERVER_IP "147.46.10.129"
#define SERVER_PORT 12345
#define BUFFER_SIZE 10000

int main() {
    int sock;
    struct sockaddr_in server_addr;
    const char *message = "This is a test message to be sent to the server. Let's see if all the data is sent correctly!";
    size_t message_len = strlen(message);
    ssize_t bytes_sent;

    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock < 0) {
        perror("Socket creation failed");
        return 1;
    }

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(SERVER_PORT);
    if (inet_pton(AF_INET, SERVER_IP, &server_addr.sin_addr) <= 0) {
        perror("Invalid address or address not supported");
        close(sock);
        return 1;
    }

    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        perror("Connection failed");
        close(sock);
        return 1;
    }

    bytes_sent = send(sock, message, message_len, 0);
    if (bytes_sent < 0) {
        printf("Warning: Failed to send some data\n");
    }

    printf("Sent message: %s\n", message);

    close(sock);
    return 0;
}
```

## Question 5.
Here is the client code that repeatedly reads the message from the server.  
Assume that all the necessary header files are included.  
However, this code may not work as you intended - it may run forever, regardless of whether the server closes the connection. Explain why.

```c
#define SERVER_IP "127.0.0.1"
#define SERVER_PORT 12345
#define BUFFER_SIZE 100

int main() {
    int sock;
    struct sockaddr_in server_addr;
    char buffer[BUFFER_SIZE] = {0};

    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock < 0) {
        perror("Socket creation failed");
        return 1;
    }

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(SERVER_PORT);
    if (inet_pton(AF_INET, SERVER_IP, &server_addr.sin_addr) <= 0) {
        perror("Invalid address");
        close(sock);
        return 1;
    }

    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        perror("Connect failed");
        close(sock);
        return 1;
    }

    printf("Connected to server. Waiting to receive data...\n");

    ssize_t bytes_read;
    while ((bytes_read = read(sock, buffer, sizeof(buffer))) >= 0) {
        printf("Received: %s\n", buffer);
        memset(buffer, 0, sizeof(buffer));
    }

    if (bytes_read < 0) {
        perror("Read failed");
    }

    close(sock);
    return 0;
}

```

## Question 6.
Consider the following simple C program, which creates three threads.  
Each thread increments two global variables, then prints their values.  
After all three threads finish, the final values of the global variables are printed.

```c
#include <stdio.h>
#include <pthread.h>

#define THREAD_COUNT 3

int x = 0; 
int y = 0; 

void *worker(void *ignore) { 
    x = x + 1; 
    y = y + x; 
    printf("x = %d, y = %d\n", x, y); 
    return NULL; 
}

int main() { 
    pthread_t threads[THREAD_COUNT];

    for (int i = 0; i < THREAD_COUNT; i++) {
        int ret = pthread_create(&threads[i], NULL, &worker, NULL);
        if (ret != 0) {
            perror("pthread_create failed");
            return 1;
        }
    }

    for (int i = 0; i < THREAD_COUNT; i++) {
        pthread_join(threads[i], NULL);
    }

    printf("final x = %d, y = %d\n", x, y); 
    return 0; 
}
```
Identify all possible values that the variables x and y may hold at the conclusion of any execution of this program, as shown in the final output line:

x: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, or values exceeding 10  
y: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, or values exceeding 10

## Question 7.
The following code handles a custom signal (SIGUSR1) by having a parent process receive signals from its child processes and printing how many times the signal was caught.

```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

void handler(int sig) {
    static int count = 0;
    printf("SIGUSR1 caught %d times\n", ++count);
}

int main() {
    signal(SIGUSR1, handler);

    for (int i = 0; i < 3; i++) {
        if (fork() == 0) {
            kill(getppid(), SIGUSR1);
            exit(0);
        }
    }

    for (int i = 0; i < 3; i++) {
        wait(NULL);
    }

    return 0;
}
```

a. Can the output order differ each time this program runs? If so, why?

b. Is accessing the `count` variable safe in the handler? If not, how can it be made safer?

## Question 8.
The following code shows how to block and then unblock SIGINT (triggered by Ctrl+C) at runtime, demonstrating delayed signal handling.

```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

void sigint_handler(int sig) {
    printf("Caught SIGINT\n");
}

int main() {
    sigset_t mask, prev;
    signal(SIGINT, sigint_handler);

    sigemptyset(&mask);
    sigaddset(&mask, SIGINT);

    // Block SIGINT
    sigprocmask(SIG_BLOCK, &mask, &prev);

    printf("SIGINT blocked. Try pressing Ctrl+C\n");
    sleep(5);

    // Unblock SIGINT
    sigprocmask(SIG_SETMASK, &prev, NULL);

    printf("SIGINT unblocked. Try pressing Ctrl+C again\n");
    sleep(5);

    return 0;
}
```

a. What happens when the user presses Ctrl+C at each stage of the program?

b. How are blocked SIGINT signals handled after the program unblocks them?

## Question 9.
Below is the provided code that implements a spin lock. Two threads attempt to increment a shared counter while using the spin lock for synchronization.

```c
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void spin_lock(int *lock) {
    while (*lock == 1) {
        // Busy-wait (spin)
    }
    *lock = 1;
}

void spin_unlock(int *lock) {
    *lock = 0;
}

int counter = 0;
int lock = 0;

void *increment(void *arg) {
    for (int i = 0; i < 100000; i++) {
        spin_lock(&lock);
        counter++;
        spin_unlock(&lock);
    }
    return NULL;
}

int main() {
    pthread_t t1, t2;

    pthread_create(&t1, NULL, increment, NULL);
    pthread_create(&t2, NULL, increment, NULL);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    printf("Final Counter Value: %d\n", counter);
    return 0;
}
```

a. What are the advantages and disadvantages of using spin locks? Provide a detailed explanation.

b. Identify the issue in the provided code that prevents the spin lock from functioning correctly. Explain why this issue occurs.

c. Suppose the provided code runs on a Single-Core environment. Does the issue identified in Q2 still persist in this environment? If so, describe the reason. If not, propose a solution to address it.

d. Discuss the differences in behavior when running the provided code in a Multi-Core environment compared to a Single-Core environment.

## Question 10.
You are tasked with writing a logging function that writes messages to a file named `log.txt`. Your current implementation uses the following code:

```c
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void log_message(const char *message) {
    static int fd = -1;

    if (fd == -1) {
        fd = open("log.txt", O_WRONLY | O_CREAT | O_APPEND, 0644);
        if (fd == -1) {
            perror("Error opening log file");
            return;
        }
    }

    size_t len = strlen(message);
    if (write(fd, message, len) == -1) {
        perror("Error writing to log file");
    }
    if (write(fd, "\n", 1) == -1) {
        perror("Error writing newline to log file");
    }
}
```

a. Is the `log_message` function reentrant? Why or why not?

b. Is the `log_message` function thread-safe? Why or why not?

c. If necessary, rewrite it to be reentrant and thread-safe.

d. After your patch, describe any potential issues with concurrent writes.

## Answer

### Question 1.  
7845, 7485, 7458, 4785, 4758, 4578  (new line (\n) after each character as well)

### Question 2.  
acabdd, abdacd, abacdd

### Question 3.  
In cases where there is a GIL restriction, such as in Python, process-based parallel programming is the appropriate choice.

### Question 4.  
If the return value is not equal to the length of the message (message_len), it's possible that only some data was sent.
When sending data, you should check the send return value and repeatedly send the remaining data.

### Question 5.  
If the return value of read() is 0, it means that the peer has closed the connection. The while loop should only run while the return value of read is greater than 0.

### Question 6.  
x: 1, 2, 3  
y: 1, 2, 3, 4, 5, 6, 7, 8, 9

### Question 7.

a.

Yes, the output order can differ. The reason is that signals are delivered asynchronously. Although the parent process will eventually receive three SIGUSR1 signals, the order in which they are processed and the exact timing depend on the OS scheduler and various other factors. Because of these non-deterministic factors, the order in which the lines "SIGUSR1 caught 1 times", "SIGUSR1 caught 2 times", and "SIGUSR1 caught 3 times" appear can vary from run to run.

b.

Strictly speaking, it may not be entirely safe. The count variable is incremented in a signal handler, which can be invoked asynchronously at almost any time. While it is a simple integer increment, there's a concern that if signals arrive in rapid succession, the increment operation might be interrupted or lead to undefined behavior.  

**A recommended solution**:  
Use a volatile sig_atomic_t type for count. The sig_atomic_t type is guaranteed to be accessed atomically relative to signal interrupts, ensuring that the increment operation won't be partially completed if another signal arrives. For example:
```c
void handler(int sig) {
    static volatile sig_atomic_t count = 0;
    printf("SIGUSR1 caught %d times\n", ++count);
}
```
This approach is simpler and commonly used to make signal handler modifications safer.

### Question 8.

a.

- While SIGINT is blocked (first 5 seconds):
Pressing Ctrl+C during this time will not invoke the handler immediately. Instead, the SIGINT signal is queued and remains pending. The program will not print "Caught SIGINT" yet.

- After SIGINT is unblocked:
Once we call sigprocmask(SIG_SETMASK, &prev, NULL), any pending SIGINT that occurred during the blocking period is now delivered. If the user pressed Ctrl+C during the first 5 seconds, the handler sigint_handler will be invoked right at this moment and print "Caught SIGINT".

After unblocking, the program prints "SIGINT unblocked. Try pressing Ctrl+C again" and sleeps another 5 seconds. During this second 5-second interval, pressing Ctrl+C will immediately call the handler and print "Caught SIGINT" since the signal is no longer blocked.

b.

Blocked SIGINT signals that arrived during the blocking period remain in the process's pending signal queue. When the program restores the original signal mask (unblocking SIGINT), any pending SIGINT signals are immediately delivered and handled by the installed handler. This demonstrates how signal blocking can delay signal handling until a more convenient time.

### Question 9.

a.

**Advantages**:

1.  **Low Overhead**: Spin locks avoid context switches because threads actively wait, making them suitable for short critical sections.
2.  **Simplicity**: Spin locks are easier to implement compared to other synchronization mechanisms.
3.  **No Sleep/Wake Overhead**: Threads stay active while waiting, avoiding kernel involvement for sleep and wake operations.

**Disadvantages**:

1.  **CPU Wastage**: Spin locks consume CPU cycles while waiting, making them inefficient for long critical sections.
2.  **Not Suitable for Single-Core Environments**: A spinning thread may block the thread holding the lock, leading to a deadlock-like situation.
3.  **No Fairness Guarantees**: Spin locks do not ensure fairness, so a thread may spin indefinitely if others continuously acquire the lock.

b.

**Issue**:

-   The spin lock implementation is not atomic. The statement `*lock = 1` is not guaranteed to execute atomically, so multiple threads could simultaneously observe `*lock == 0` and set it to `1`, allowing both to enter the critical section.

**Why It Occurs**:

-   The `*lock = 1` operation involves reading, modifying, and writing the value of `lock`. Without atomicity, this sequence can be interrupted, leading to race conditions.

c.

**Does the Issue Persist?**

-   Yes, the issue persists because the lack of atomicity in the lock operation remains a problem. However, an additional issue arises in a Single-Core environment:
    -   A spinning thread will block the lock-holding thread from progressing, as both threads cannot execute simultaneously.

**Solution**:

-   Use an atomic operation to implement the spin lock. In GCC, you can use `__sync_lock_test_and_set` to make the spin lock work correctly:

```c
void spin_lock(int *lock) {
    while (__sync_lock_test_and_set(lock, 1)) {
        // Busy-wait
    }
}

void spin_unlock(int *lock) {
    __sync_lock_release(lock);
}
``` 

d.

**Multi-Core Environment**:

-   The spinning thread can run on a separate core, allowing the lock-holding thread to make progress. Spin locks are more efficient in Multi-Core environments, especially for short critical sections.

**Single-Core Environment**:

-   The spinning thread prevents the lock-holding thread from progressing because both cannot execute simultaneously. This can lead to deadlock-like behavior and makes spin locks inefficient on Single-Core systems.

### Question 10.

a.

-   The function is **not reentrant** because it uses a `static` variable (`fd`) to store the file descriptor. If the function is interrupted by a signal or called concurrently by another thread, the state of `fd` can be corrupted.

b.

-   The function is **not thread-safe**:
    1.  Multiple threads share the `static` variable `fd`, leading to race conditions.
    2.  Concurrent writes to the same file descriptor can interleave or corrupt log entries.

c.

To make the function both reentrant and thread-safe:

```c
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <pthread.h>

pthread_mutex_t log_mutex = PTHREAD_MUTEX_INITIALIZER;

void log_message(const char *message) {
    pthread_mutex_lock(&log_mutex);

    int fd = open("log.txt", O_WRONLY | O_CREAT | O_APPEND, 0644);
    if (fd == -1) {
        perror("Error opening log file");
        pthread_mutex_unlock(&log_mutex);
        return;
    }

    size_t len = strlen(message);
    if (write(fd, message, len) == -1) {
        perror("Error writing to log file");
    }
    if (write(fd, "\n", 1) == -1) {
        perror("Error writing newline to log file");
    }

    close(fd);
    pthread_mutex_unlock(&log_mutex);
}
```

d.

**Performance Overhead**:
    
- Opening and closing the file for each log entry adds significant overhead in high-frequency logging scenarios.
- Using a mutex serializes access, which could lead to contention if many threads log simultaneously.
